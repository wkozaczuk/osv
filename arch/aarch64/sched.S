#void cpu::reschedule_from_interrupt(bool called_from_yield,
#                                    thread_runtime::duration preempt_after)
.global reschedule_from_interrupt
.type reschedule_from_interrupt, @function
reschedule_from_interrupt:
        #.cfi_startproc simple
        #.cfi_def_cfa sp, 0
        stp     x29, x30, [sp, #-192]!
        #.cfi_def_cfa x29, -192
        #.cfi_def_cfa x30, -188
        #.cfi_adjust_cfa_offset 192
        mov	x29, sp

        #Call cpu_schedule_next_thread() to determine next thread to switch to if any
        bl cpu_schedule_next_thread

	#The cpu_schedule_next_thread returns thread_switch_data in x0 and x1,
        #where x0 holds old_thread_state and x1 holds new_thread_state
        #If cpu_schedule_next_thread() returns thread_switch_data with null pointers, exit
        cmp x0, #0
        b.eq 2f

        #Store all regular callee-save registers on the old thread stack
        stp	x19, x20, [sp, #16]
       //.cfi_def_cfa x19, 0
       //.cfi_def_cfa x20, 8
        stp	x21, x22, [sp, #32]
       //.cfi_def_cfa x19, 16
       //.cfi_def_cfa x20, 24
        stp	x23, x24, [sp, #48]
       //.cfi_def_cfa x19, 32
       //.cfi_def_cfa x20, 40
        stp	x25, x26, [sp, #64]
       //.cfi_def_cfa x19, 48
       //.cfi_def_cfa x20, 56
        stp	x27, x28, [sp, #80]
       //.cfi_def_cfa x19, 64
       //.cfi_def_cfa x20, 72

        #Store all SIMD/FP callee-save registers on the old thread stack
        stp	d8, d9, [sp, #96]
        stp	d10, d11, [sp, #112]
        stp	d12, d13, [sp, #128]
        stp	d14, d15, [sp, #144]

        #Store FP Control Register with flags that control rounding, etc
        mrs     x2, fpcr
        str     x2, [sp, #160]

        #Switch to new thread
        ldr	x2, [x1, #32]     //Fetch _tcb of the new thread
        msr	tpidr_el0, x2     //Set thread pointer
        isb
        dsb ish

        str     x29, [x0, #0]     //Save frame pointer of the old thread
        mov     x3, sp            //Fetch old thread stack pointer
        adr     x4, 1f            //Fetch old thread instruction point
        stp     x3, x4, [x0, #16] //Save old thread sp and pc

        ldp     x29, x0, [x1, #0] //Set frame pointer of the new thread and this (x0) of the new thread
                                  //Please note that the pc may point to thread_main_c(thread*) which is
                                  //why we have to set x0 (1st argument) to new thread object
        ldp     x3, x4, [x1, #16] //Fetch new thread sp and pc
        mov     sp, x3            //Set new thread stack pointer
        blr     x4                //Jump to the new thread pc

1:
        #Restore all regular callee-save registers from the new thread stack
        ldp     x19, x20, [sp, #16]
        //.cfi_restore x20
        //.cfi_restore x19
        ldp     x21, x22, [sp, #32]
        //.cfi_restore x22
        //.cfi_restore x21
        ldp     x23, x24, [sp, #48]
        //.cfi_restore x24
        //.cfi_restore x23
        ldp     x25, x26, [sp, #64]
        //.cfi_restore x26
        //.cfi_restore x25
        ldp     x27, x28, [sp, #80]
        //.cfi_restore x28
        //.cfi_restore x27

        #Restore all SIMD/FP callee-save registers from the new thread stack
        ldp	d8, d9, [sp, #96]
        ldp	d10, d11, [sp, #112]
        ldp	d12, d13, [sp, #128]
        ldp	d14, d15, [sp, #144]

        #Restore FP Control Register with flags that control rounding, etc
        ldr     x2, [sp, #160]
        msr     fpcr, x2

        #Call destroy_current_cpu_terminating_thread()
        bl destroy_current_cpu_terminating_thread

2:
        ldp     x29, x30, [sp], #192
        #.cfi_adjust_cfa_offset -192
        ret
        #.cfi_endproc
